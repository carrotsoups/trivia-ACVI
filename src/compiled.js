export const BUZZER =
  "data:audio/mpeg;base64,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yqI/zYjFCTSqF2/5T4A14vsWu/wb0AF4QEfWIeAY8I4IsMaNngDdAPYALcBvIBKBSQ7y14XNBfAiANzQBojkkUDERSFzfGPLxXAqABYIAAU6LJHfwiQLcg3VAGKF/RCACIS7ROXKP8DjAOuEJiCCphyIr4gCNYmTWZJmK2/9cTyQIfw2UP2EAhXiAjm/X//40RySEJsfw1aJsEJRyQxS45pES6RX1o1L6X//1GJqY0xBTUUzLjk5LjVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmTwAAakbFUlYwACAAANIKAAARgNoVWZqYAAAAA0gwAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUACiQD/////+o8V/+JbKn/iVVMQU1FMy45OS41VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkSY/wigDAnwBADAAADSDgAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV";

// a list of supported buzz controller devices
const DEVICES = [
  {
    // Sony Buzz Controller
    vendorId: 0x054c,
    productId: 0x1000,
  },
  {
    // Sony Buzz Controller
    vendorId: 0x054c,
    productId: 0x0002,
  },
];

// names of the buttons in the order that they appear in the binary input report
export const NAMES = ["red", "yellow", "green", "orange", "blue"];

// how many controllers/buttons per controller each buzz controller has
export const CONTROLLERS = 4;
export const BUTTONS = 5;

// a class to manage receiving input from a buzz controller
export class BuzzController {
  // initialize the class
  constructor() {
    // a callback is used to alert of new input data from the buzz controller
    this.inputCallback = null;
    // a callback to alert of a new connected controller
    this.connectedCallback = null;

    // an array of connected buzz controllers
    this.devices = [];

    // an array of lights
    this.lights = [];
  }

  // set the input callback
  setInputCallback(callback) {
    this.inputCallback = callback;
  }

  // set the connected callback
  setConnectedCallback(callback) {
    this.connectedCallback = callback;
  }

  // connect to a buzz controller
  connect() {
    return new Promise(async (res, rej) => {
      // request a buzz controller devices using the hid class
      const devices = await navigator.hid.getDevices();

      // loop over all the devices
      for (const device of devices) {
        // open the device
        await device.open();

        // setup the device
        this.setupDevice(device);
      }

      // make sure the lights on the new controllers are off
      this.updateLights();

      // resolve a success
      res(true);
    });
  }

  // add a new trusted device
  addDevice() {
    return new Promise(async (res, rej) => {
      // request a buzz controller devices using the hid class
      const [device] = await navigator.hid.requestDevice({
        filters: DEVICES,
      });

      if (!device) res(false);

      // make a connection to the device
      await device.open();

      // setup the device
      this.setupDevice(device);

      // make sure the lights on the new controllers are off
      this.updateLights();

      // resolve a success
      res(true);
    });
  }

  // append a device to the device array and initialize custom fields
  setupDevice(device) {
    // add an event listener to be alerted of new input data
    device.addEventListener("inputreport", (event) => this.inputEvent(event));

    // save the device id for controller number offset
    device.id = this.devices.length;

    // an array to keep track of held buttons to calculate newly pressed and released buttons on an input interrupt
    device.buttons = [];

    // initialize the array
    for (let i = 0; i < CONTROLLERS; i++) {
      // add a light index for each controller
      this.lights.push(false);

      // create a field for each button
      const buttons = [];
      for (let j = 0; j < BUTTONS; j++) {
        buttons.push(false);
      }
      device.buttons.push(buttons);
    }

    // append the device
    this.devices.push(device);

    // create the update data for the callback
    const update = {
      offset: device.id,
      device,
    };

    // send the new data to the callback function (if it was set)
    if (this.connectedCallback != null) this.connectedCallback(update);
  }

  setLights(enabled) {
    // turn off all of the lights on all the controllers
    for (let i = 0; i < this.devices.length * CONTROLLERS; i++) {
      // set the index
      this.setLight(i, false);
    }
  }

  // set a light of a controller to enabled
  setLight(controller, enabled) {
    // save the enabled variable in the controller
    this.lights[controller] = enabled;

    // send the lights data to the controllers
    this.updateLights();
  }

  // send the lights data to all of the connected controllers
  updateLights() {
    return new Promise(async (res, rej) => {
      // loop over all of the connected devices
      for (let i = 0; i < this.devices.length; i++) {
        // the start of the packet
        let packet = [0x00];

        // loop over all the buttons
        for (let j = 0; j < BUTTONS; j++) {
          // add the correct byte to the packet
          packet.push(this.lights[j + i * CONTROLLERS] == false ? 0x00 : 0xff);
        }

        // create the binary array
        const buffer = Uint8Array.from(packet);

        // send the packet to the device
        this.devices[i].sendReport(0x00, buffer);
      }

      // resolve a success
      res(true);
    });
  }

  // input data interrupt
  inputEvent(event) {
    // retrive the input data from the event
    const { data, device } = event;

    // controller id offset
    const offset = (device.id ?? -1) * 4;

    // create the result array of newly pressed buttons
    const update = {
      pressed: [],
      released: [],
    };

    // a variable to store the input data as one interger, instead of 3 bytes
    let controllerData = 0;

    // copy the input data bytes in order to the single integer
    for (let i = 0; i < 3; i++) {
      // or the current controller data with the new byte
      controllerData |= data.getUint8(i + 2) << (i * 8);
    }

    // loop over ever controller and button
    for (let i = 0; i < CONTROLLERS * BUTTONS; i++) {
      // calculate the current controller/button index
      let controller = Math.floor(i / BUTTONS);
      let button = i % BUTTONS;

      // check if the current bit is set in the controller data, which means the button is held
      let pressed = ((controllerData >> i) & 1) == 1;

      // if pressed is true, and the button was not held, append the newly pressed button to the pressed array
      if (pressed == true && device.buttons[controller][button] == false) {
        update.pressed.push({
          controller: controller + offset,
          button,
          device: device.id,
        });
        device.buttons[controller][button] = true;
      }
      // if pressed is false, and the button was held, append the newly released button to the released array
      else if (pressed == false && device.buttons[controller][button] == true) {
        update.released.push({
          controller: controller + offset,
          button,
          device: device.id,
        });
        device.buttons[controller][button] = false;
      }
    }

    // shuffle the arrays in the event that two buttons are pressed at the exact same time
    this.shuffle(update.pressed);
    this.shuffle(update.released);

    // send the new data to the callback function (if it was set)
    if (this.inputCallback != null) this.inputCallback(update);
  }

  // a function to shuffle an array; https://stackoverflow.com/a/12646864
  shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }
}

export class Game {
  constructor() {
    // create an instance of the buzz controller and add callbacks
    this.buzzController = new BuzzController();
    this.buzzController.setInputCallback((update) =>
      this.inputCallback(update)
    );
    this.buzzController.setConnectedCallback((update) =>
      this.connectedCallback(update)
    );

    this.buzzer = new Audio(BUZZER);

    // the number of connected controllers
    this.controllers = 0;

    // the page states enum
    this.pageStates = {
      NONE: 0,
      SETUP: 1,
      GAME: 2,
    };

    // the current state
    this.pageState = this.pageStates.NONE;

    this.gameStates = {
      WAITING_NORMAL: 1,
      LOCKED_NORMAL: 2,
      WAITING_A: 3,
      WAITING_B: 4,
      LOCKED_TEAM: 5,
      LOCKED_A: 5,
      LOCKED_B: 6,
      HIGHLIGHT_TEAM: 7,
      HIGHLIGHT_A: 7,
      HIGHLIGHT_B: 8,
      ASSIGNED: 9,
      TEST: 255,
    };

    this.gameState = this.gameStates.NONE;

    this.teams = {
      NONE: -1,
      A: 0,
      B: 1,
    };

    this.currentTeam = this.teams.NONE;
    this.currentController = 0;

    this.score = [0, 0];

    this.setupPage = document.getElementById("setup");
    this.connectedControllers = document.getElementById("connectedControllers");
    this.connectControllerButton = document.getElementById("connectController");
    this.connectControllerButton.addEventListener("click", () =>
      this.buzzController.addDevice()
    );

    this.gamePage = document.getElementById("game");
    this.status = document.getElementById("status");

    this.acceptButton = document.getElementById("main-accept");
    this.acceptButton.addEventListener("click", () => {
      this.accept();
    });
    this.denyButton = document.getElementById("main-deny");
    this.denyButton.addEventListener("click", () => {
      this.deny();
    });

    this.playerNameSelects = document.querySelectorAll(".person-name");
    for (let i = 0; i < this.playerNameSelects.length; i++) {
      this.playerNameSelects[i].addEventListener("click", () => {
        this.nameChange(i);
      });
    }
    this.playerLights = document.querySelectorAll(".person-light");
    this.playerAcceptButtons = document.querySelectorAll(".person-accept");
    for (let i = 0; i < this.playerAcceptButtons.length; i++) {
      this.playerAcceptButtons[i].addEventListener("click", () => {
        this.acceptPlayer(i);
      });
    }
    this.playerDenyButtons = document.querySelectorAll(".person-deny");
    for (let i = 0; i < this.playerDenyButtons.length; i++) {
      this.playerDenyButtons[i].addEventListener("click", () => {
        this.denyPlayer(i);
      });
    }

    this.clearBuzzersButton = document.getElementById("clear-buzzers");
    this.clearBuzzersButton.addEventListener("click", () => {
      this.clear();
      this.setGameState(this.gameStates.WAITING_NORMAL);
    });

    this.normalQuestionButtons = document.getElementById("normal-button");
    this.selectTeamAButton = document.getElementById("team-a-select");
    this.selectTeamAButton.addEventListener("click", () => {
      this.selectTeam(this.teams.A);
    });
    this.selectTeamBButton = document.getElementById("team-b-select");
    this.selectTeamBButton.addEventListener("click", () => {
      this.selectTeam(this.teams.B);
    });
    this.assignedQuestionButton = document.getElementById("assigned-question");
    this.assignedQuestionButton.addEventListener("click", () => {
      this.clear();
      this.setGameState(this.gameStates.ASSIGNED);
    });
    this.addNameButton = document.getElementById("add-name");
    this.addNameButton.addEventListener("click", () => {
      const data = prompt("Please enter a new name:");
      if (!data) return;
      this.appendName(data);
    });
    this.testButton = document.getElementById("test-buzzers");
    this.testButton.addEventListener("click", () => {
      this.clear();
      this.setGameState(this.gameStates.TEST);
    });

    this.assignedQuestionButtons = document.getElementById("assigned-button");
    this.normalQuestionButton = document.getElementById("normal-question");
    this.normalQuestionButton.addEventListener("click", () => {
      this.clear();
      this.setGameState(this.gameStates.WAITING_NORMAL);
    });

    this.scoreIndicators = document.querySelectorAll(".score");
    this.scoreIncrease = document.querySelectorAll(".increase-score");
    for (let i = 0; i < this.scoreIncrease.length; i++) {
      this.scoreIncrease[i].addEventListener("click", () => {
        this.updateScores(i, 10);
      });
    }
    this.scoreDecease = document.querySelectorAll(".decrease-score");
    for (let i = 0; i < this.scoreDecease.length; i++) {
      this.scoreDecease[i].addEventListener("click", () => {
        this.updateScores(i, -10);
      });
    }

    document.addEventListener("keydown", (event) => {
      switch (event.key.toLowerCase()) {
        case "a":
          this.accept();
          break;
        case "d":
          this.deny();
          break;
        case "c":
          this.clear();
          this.setGameState(this.gameStates.WAITING_NORMAL);
          break;
        case "z":
          this.selectTeam(this.teams.A);
          break;
        case "x":
          this.selectTeam(this.teams.B);
          break;
        case "q":
          if (this.gameState != this.gameStates.ASSIGNED) {
            this.setGameState(this.gameStates.ASSIGNED);
          } else {
            this.setGameState(this.gameStates.WAITING_NORMAL);
          }
          break;
        case "t":
          if (this.gameState != this.gameStates.TEST) {
            this.clear();
            this.setGameState(this.gameStates.TEST);
          } else {
            this.clear();
            this.setGameState(this.gameStates.WAITING_NORMAL);
          }
          break;
      }
    });

    this.setPageState(this.pageStates.SETUP);
    this.setGameState(this.gameStates.WAITING_NORMAL);
  }

  // start the game
  start() {
    return new Promise(async (res, rej) => {
      if (!("hid" in navigator)) {
        alert(
          "Sorry, the WebHID api required to connect to the conrollers is not supported by your browser."
        );
        res(false);
        return;
      }

      // connect to previously connected controllers
      await this.buzzController.connect();

      this.loadNames();

      res(true);
    });
  }

  loadNames() {
    this.names = ["None"];

    const data = localStorage.getItem("name");
    if (data) {
      this.names.push(...JSON.parse(data));
    }

    this.resetNames();
    this.setNames();
  }

  saveNames() {
    localStorage.setItem(
      "name",
      JSON.stringify(this.names.slice(1, this.names.length))
    );
  }

  resetNames() {
    const options = document.querySelectorAll(`.person-option`);
    for (const option of options) {
      option.parentNode.removeChild(option);
    }
  }

  appendName(name) {
    this.names.push(name);

    this.saveNames();

    let option = document.createElement("option");
    option.classList.add(`person-option`);
    option.classList.add(`person-name-${name}`);
    option.value = name;
    option.innerText = name;
    this.appendNameOption(option);
  }

  setNames() {
    for (let i = 0; i < this.names.length; i++) {
      let option = document.createElement("option");
      option.classList.add(`person-option`);
      option.classList.add(`person-name-${this.names[i]}`);
      option.value = this.names[i];
      option.innerText = this.names[i];
      this.appendNameOption(option);
    }
  }

  appendNameOption(option) {
    for (let i = 0; i < this.playerNameSelects.length; i++) {
      this.playerNameSelects[i].appendChild(option.cloneNode(true));
    }
  }

  nameChange(index) {
    let usedNames = [];

    for (let i = 0; i < this.playerNameSelects.length; i++) {
      const value = this.playerNameSelects[i].value;
      if (value != "" && value != "None") {
        usedNames.push(value);
      }
    }

    for (let i = 0; i < this.names.length; i++) {
      const options = document.querySelectorAll(
        `.person-name-${this.names[i]}`
      );
      for (const option of options) {
        option.removeAttribute("disabled");
      }
    }

    for (let i = 0; i < usedNames.length; i++) {
      const options = document.querySelectorAll(`.person-name-${usedNames[i]}`);
      for (const option of options) {
        option.setAttribute("disabled", "true");
      }
    }
  }

  // listen for a button change on the controllers
  inputCallback(update) {
    // loop over the newly pressed buttons
    for (let i = 0; i < update.pressed.length; i++) {
      // get the controller and button index
      const { controller, button, device } = update.pressed[i];

      if (button == 0) {
        if (this.gameState == this.gameStates.WAITING_NORMAL) {
          this.currentTeam = device;
          this.currentController = controller;
          this.setLight(controller, true);
          this.setGameState(this.gameStates.LOCKED_NORMAL);
          this.buzz();
        } else if (
          this.gameState == this.gameStates.WAITING_A &&
          device == this.teams.A
        ) {
          this.currentTeam = device;
          this.currentController = controller;
          this.setLight(controller, true);
          this.setGameState(this.gameStates.LOCKED_A);
          this.buzz();
        } else if (
          this.gameState == this.gameStates.WAITING_B &&
          device == this.teams.B
        ) {
          this.currentTeam = device;
          this.currentController = controller;
          this.setLight(controller, true);
          this.setGameState(this.gameStates.LOCKED_B);
          this.buzz();
        } else if (this.gameState == this.gameStates.TEST) {
          this.setLight(controller, true);
        }
      }
    }

    // loop over the newly released buttons
    for (let i = 0; i < update.released.length; i++) {
      // get the controller and button index
      const { controller, button, device } = update.released[i];

      if (button == 0 && this.gameState == this.gameStates.TEST) {
        this.setLight(controller, false);
      }
    }
  }

  // listen for a new controller connected
  connectedCallback(update) {
    // get the controllers offset or id
    const { offset } = update;

    // increment the controllers connected
    this.controllers++;

    this.connectedControllers.innerText = `There ${
      this.controllers == 1 ? "is" : "are"
    } ${this.controllers} controller${
      this.controllers == 1 ? "" : "s"
    } connected`;

    if (this.controllers == 2 && this.pageState == this.pageStates.SETUP) {
      this.setPageState(this.pageStates.GAME);
    }
  }

  buzz() {
    this.buzzer.pause();
    this.buzzer.currentTime = 0;
    this.buzzer.play();
  }

  accept() {
    if (
      this.gameState == this.gameStates.LOCKED_NORMAL ||
      this.gameState == this.gameStates.LOCKED_A ||
      this.gameState == this.gameStates.LOCKED_B
    ) {
      this.updateScores(this.currentTeam, 10);
      this.setGameState(this.gameStates.WAITING_NORMAL);
      this.setLights(false);
    }
  }

  deny() {
    if (this.gameState == this.gameStates.LOCKED_NORMAL) {
      this.setGameState(
        this.currentTeam == this.teams.A
          ? this.gameStates.WAITING_B
          : this.gameStates.WAITING_A
      );

      this.setLights(false);
    } else if (
      this.gameState == this.gameStates.LOCKED_A ||
      this.gameState == this.gameStates.LOCKED_B
    ) {
      this.setGameState(this.gameStates.WAITING_NORMAL);

      this.setLights(false);
    }
  }

  acceptPlayer(index) {
    this.updateScores(Math.floor(index / 4), 10);
  }

  denyPlayer(index) {
    const player = this.playerNameSelects[index].value;
    if (player == `None`) {
      console.error(
        `An answer was denied, but there was no player assigned to the controller`
      );
      return;
    }
    console.log(`${player} got the assigned question wrong`);
  }

  clear() {
    this.setLights(false);
  }

  selectTeam(team) {
    this.clear();

    if (this.gameState == this.gameStates.HIGHLIGHT_TEAM + team) {
      this.setGameState(this.gameStates.WAITING_NORMAL);
      return;
    }

    this.setGameState(this.gameStates.HIGHLIGHT_TEAM + team);
    this.currentTeam = team;
    this.setTeamLights(team, true);
  }

  updateScores(team, amount) {
    this.score[team] += amount;
    this.scoreIndicators[team].innerText = this.score[team];
  }

  setLight(controller, enabled) {
    try {
      this.buzzController.setLight(controller, enabled);
    } catch (e) {
      console.log(e);
    }

    this.playerLights[controller].style.backgroundColor = enabled
      ? "red"
      : "white";
  }

  setLights(enabled) {
    try {
      this.buzzController.setLights(enabled);
    } catch (e) {
      console.log(e);
    }
    for (let i = 0; i < this.playerLights.length; i++) {
      this.playerLights[i].style.backgroundColor = enabled ? "red" : "white";
    }
  }

  setTeamLights(team, enabled) {
    for (let i = 0; i < CONTROLLERS; i++) {
      try {
        this.buzzController.setLight(team * 4 + i, enabled);
      } catch (e) {
        console.log(e);
      }
      this.playerLights[team * 4 + i].style.backgroundColor = enabled
        ? "red"
        : "white";
    }
  }

  // change the state
  setPageState(state) {
    this.setupPage.style.display = "none";
    this.gamePage.style.display = "none";

    if (state == this.pageStates.SETUP) {
      this.setupPage.style.display = "flex";
    } else if (state == this.pageStates.GAME) {
      this.gamePage.style.display = "flex";
    }

    // save the state for future reference
    this.pageState = state;
  }

  setGameState(state) {
    this.acceptButton.style.display = "none";
    this.denyButton.style.display = "none";

    this.normalQuestionButtons.style.display = "none";
    this.assignedQuestionButtons.style.display = "none";

    for (const acceptButton of this.playerAcceptButtons) {
      acceptButton.style.display = "none";
    }
    for (const denyButton of this.playerDenyButtons) {
      denyButton.style.display = "none";
    }

    if (state == this.gameStates.ASSIGNED) {
      for (const acceptButton of this.playerAcceptButtons) {
        acceptButton.style.display = "flex";
      }
      for (const denyButton of this.playerDenyButtons) {
        denyButton.style.display = "flex";
      }
      this.assignedQuestionButtons.style.display = "flex";
    } else {
      this.acceptButton.style.display = "flex";
      this.denyButton.style.display = "flex";
      this.normalQuestionButtons.style.display = "flex";
    }

    let text = ``;

    switch (state) {
      case this.gameStates.WAITING_NORMAL:
        text = `Waiting for buzzer from any team...`;
        break;
      case this.gameStates.LOCKED_NORMAL: {
        let team = `Team ${this.currentTeam == this.teams.A ? "A" : "B"}`;
        if (this.playerNameSelects[this.currentController].value != "None") {
          team = this.playerNameSelects[this.currentController].value;
        }
        text = `${team} answered.`;
        break;
      }
      case this.gameStates.WAITING_A:
        text = `Waiting for buzzer from Team A...`;
        break;
      case this.gameStates.WAITING_B:
        text = `Waiting for buzzer from Team B...`;
        break;
      case this.gameStates.LOCKED_A: {
        let team = `Team A`;
        if (
          this.currentController < 4 &&
          this.playerNameSelects[this.currentController].value != "None"
        ) {
          team = this.playerNameSelects[this.currentController].value;
        }
        text = `${team} answered after Team B got the answer wrong.`;
        break;
      }
      case this.gameStates.LOCKED_B:
        let team = `Team B`;
        if (
          this.currentController >= 4 &&
          this.playerNameSelects[this.currentController].value != "None"
        ) {
          team = this.playerNameSelects[this.currentController].value;
        }
        text = `${team} answered after Team A got the answer wrong.`;
        break;
      case this.gameStates.HIGHLIGHT_A:
        text = `Selected Team A.`;
        break;
      case this.gameStates.HIGHLIGHT_B:
        text = `Selected Team B.`;
        break;
      case this.gameStates.TEST:
        text = `Testing Mode.`;
        break;
      default:
        break;
    }

    this.status.innerText = text;

    // save the state for future reference
    this.gameState = state;
  }
}

// create an instance of the game
const game = new Game();

// start the game after the page loaded
game.start();

window.game = game;
